as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2)) %>%
select(-`%InROPE`, -`%>compVal`)
load(file = analysis_file_name)
BEST <- BESTmcmc(change_score[condition == "a"], change_score[condition == "b"]) # SET THE DV AND CONDITION NAMES HERE
setwd("~/Git/Automated Reporting/")
# Data acquisition
data_df <-read.csv("dataset.csv")
# BEST test
attach(data_df)  # use the input data frame for all tests below
BEST <- BESTmcmc(change_score[condition == "a"], change_score[condition == "b"]) # SET THE DV AND CONDITION NAMES HERE
save(BEST, file = analysis_file_name)
BEST_output_df <-
summary(BEST,
ROPEeff = ROPE) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2)) %>%
select(-`%InROPE`, -`%>compVal`)
n_eff_strings <- capture.output(print(BEST))  # this is dependant on the width of your console being adequte to print all columns on one row
n_eff_strings <-
n_eff_strings %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%
dplyr::filter(rowname > 3) %>%
dplyr::filter(rowname <= 8) %>%
select(-rowname)
colnames(n_eff_strings) <- "strings"
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff)
View(MCMC_checks)
View(MCMC_checks)
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_insufficient = ifelse(Rhat <= 10000, 1, 0),
n_eff_insufficient = ifelse(n.eff <= 10000, 1, 0))
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_insufficient = ifelse(Rhat <= 10000, 1, 0),
n_eff_insufficient = ifelse(n.eff > 1.05, 1, 0))
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_insufficient = ifelse(Rhat > 1.05, 1, 0),
n_eff_insufficient = ifelse(n.eff <= 10000, 1, 0))
?BEST
?summarize
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_insufficient = ifelse(Rhat > 1.05, 1, 0),  # insufficient convergence if less than value
n_eff_insufficient = ifelse(n.eff <= 10000, 1, 0)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_insufficient = max(Rhat_insufficient),
n_eff_insufficient = max(n_eff_insufficient))
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_insufficient = ifelse(Rhat > 1.05, 1, 0),  # insufficient convergence if less than value
n_eff_insufficient = ifelse(n.eff <= 10000, 1, 0)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_insufficient = as.boolean(max(Rhat_insufficient)),
n_eff_insufficient = as.boolean(max(n_eff_insufficient)))
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_insufficient = ifelse(Rhat > 1.05, 1, 0),  # insufficient convergence if less than value
n_eff_insufficient = ifelse(n.eff <= 10000, 1, 0)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_insufficient = as.logical(max(Rhat_insufficient)),
n_eff_insufficient = as.logical(max(n_eff_insufficient)))
n_eff_strings <-
capture.output(print(BEST))  %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%
dplyr::filter(rowname > 3) %>%
dplyr::filter(rowname <= 8) %>%
select(-rowname)
n_eff_strings
colnames(n_eff_strings) <- "strings"
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_insufficient = ifelse(Rhat > 1.05, 1, 0),  # insufficient convergence if less than value
n_eff_insufficient = ifelse(n.eff <= 10000, 1, 0)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_insufficient = as.logical(max(Rhat_insufficient)),
n_eff_insufficient = as.logical(max(n_eff_insufficient)))
MCMC_checks
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_insufficient = as.logical(min(Rhat_insufficient)),
n_eff_insufficient = as.logical(min(n_eff_insufficient)))
?min
n_eff_strings
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff)
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1))
MCMC_checks
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_insufficient = as.logical(min(Rhat_insufficient)),
n_eff_insufficient = as.logical(min(n_eff_insufficient)))
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_sufficient = as.logical(min(Rhat_sufficient)),
n_eff_sufficient = as.logical(min(n_eff_sufficient)))
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1))
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_sufficient = as.logical(min(Rhat_sufficient)),
n_eff_sufficient = as.logical(min(n_eff_sufficient)))
MCMC_convergence        <- MCMC_checks$Rhat_sufficient
MCMC_effective_n        <- MCMC_checks$n_eff_sufficient
es_mode                 <- BEST_output_df %>% filter(rowname == "effSz") %>% .$mode
es_hdi_low              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIlo
es_hdi_high             <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIup
es_greater_zero         <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_greater_than_zero
es_in_rope              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_in_rope
m_condition_a           <- BEST_output_df %>% filter(rowname == "mu1") %>% .$mean
m_condition_a           <- round(m_condition_a, 2)
m_condition_b           <- BEST_output_df %>% filter(rowname == "mu2") %>% .$mean
m_condition_b           <- round(m_condition_b, 2)
?BEST
BEST <- BESTmcmc(change_score[condition == "a"],  # SET THE DV AND CONDITION NAMES HERE
change_score[condition == "b"],  # SET THE DV AND CONDITION NAMES HERE
burnInSteps = 1000,  # Increase this if convergence is insufficient
numSavedSteps = 2e+05,  # Increase this or thinsteps if effective sample size is insufficient
thinSteps = 1)
save(BEST, file = analysis_file_name)
BEST_output_df <-
summary(BEST,
ROPEeff = ROPE) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2)) %>%
select(-`%InROPE`, -`%>compVal`)
n_eff_strings <-
capture.output(print(BEST)) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%
dplyr::filter(rowname > 3) %>%
dplyr::filter(rowname <= 8) %>%
select(-rowname)
colnames(n_eff_strings) <- "strings"
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_sufficient = as.logical(min(Rhat_sufficient)),
n_eff_sufficient = as.logical(min(n_eff_sufficient)))
BEST_output_df
BEST_output_df
plotAll(BEST, ROPEeff = ROPE, showCurve = TRUE)
MCMC_checks_string      <- iflese(MCMC_convergence = FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
ifelse(MCMC_effective_n = FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters and comparisons of interest."))
MCMC_checks_string      <- ifelse(MCMC_convergence = FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
ifelse(MCMC_effective_n = FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters."))
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
ifelse(MCMC_effective_n == FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters."))
MCMC_checks_string
n_eff_strings <-
capture.output(print(BEST)) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%
dplyr::filter(rowname > 3) %>%
dplyr::filter(rowname <= 8) %>%
select(-rowname)
colnames(n_eff_strings) <- "strings"
BEST_output_df <-
summary(BEST,
ROPEeff = ROPE) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2)) %>%
select(-`%InROPE`, -`%>compVal`)
########################################################################
## MCMC convergence and n.eff assessment
# NB this is dependant on the width of your console being adequte to print all columns on one row
n_eff_strings <-
capture.output(print(BEST)) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%
dplyr::filter(rowname > 3) %>%
dplyr::filter(rowname <= 8) %>%
select(-rowname)
colnames(n_eff_strings) <- "strings"
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_sufficient = as.logical(min(Rhat_sufficient)),
n_eff_sufficient = as.logical(min(n_eff_sufficient)))
MCMC_convergence        <- MCMC_checks$Rhat_sufficient
MCMC_effective_n        <- MCMC_checks$n_eff_sufficient
es_mode                 <- BEST_output_df %>% filter(rowname == "effSz") %>% .$mode
es_hdi_low              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIlo
es_hdi_high             <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIup
es_greater_zero         <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_greater_than_zero
es_in_rope              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_in_rope
m_condition_a           <- BEST_output_df %>% filter(rowname == "mu1") %>% .$mean
m_condition_a           <- round(m_condition_a, 2)
m_condition_b           <- BEST_output_df %>% filter(rowname == "mu2") %>% .$mean
m_condition_b           <- round(m_condition_b, 2)
########################################################################
# construct strings from output
# MCMC convergence
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
ifelse(MCMC_effective_n == FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters."))
MCMC_checks_string
rm(list=ls())
########################################################################
## Dependencies
library(BEST)
library(dplyr)
library(reshape2)
########################################################################
# Specific data, variables, and parameters of test
DV_name                 <- "IAT D1 change scores"
condition_a_name        <- "the flowers condition"
condition_b_name        <- "the insects condition"
analysis_file_name      <- "BEST.RData"
output_file_name        <- "output BEST.txt"
ROPE                    <- c(-0.2, 0.2)  # region of practical equivalence (ROPE) for assessing group equality.
# working directory where output will be saved
setwd("~/Git/Automated Reporting/")
# Data acquisition
data_df <-read.csv("dataset.csv")
# BEST test
load(file = analysis_file_name)
BEST_output_df <-
summary(BEST,
ROPEeff = ROPE) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2)) %>%
select(-`%InROPE`, -`%>compVal`)
########################################################################
## MCMC convergence and n.eff assessment
# NB this is dependant on the width of your console being adequte to print all columns on one row
n_eff_strings <-
capture.output(print(BEST)) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%
dplyr::filter(rowname > 3) %>%
dplyr::filter(rowname <= 8) %>%
select(-rowname)
colnames(n_eff_strings) <- "strings"
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_sufficient = as.logical(min(Rhat_sufficient)),
n_eff_sufficient = as.logical(min(n_eff_sufficient)))
########################################################################
# View results
# full output
BEST_output_df
# plot
plotAll(BEST, ROPEeff = ROPE, showCurve = TRUE)
########################################################################
## extract individual variables for easier printing
MCMC_convergence        <- MCMC_checks$Rhat_sufficient
MCMC_effective_n        <- MCMC_checks$n_eff_sufficient
es_mode                 <- BEST_output_df %>% filter(rowname == "effSz") %>% .$mode
es_hdi_low              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIlo
es_hdi_high             <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIup
es_greater_zero         <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_greater_than_zero
es_in_rope              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_in_rope
m_condition_a           <- BEST_output_df %>% filter(rowname == "mu1") %>% .$mean
m_condition_a           <- round(m_condition_a, 2)
m_condition_b           <- BEST_output_df %>% filter(rowname == "mu2") %>% .$mean
m_condition_b           <- round(m_condition_b, 2)
########################################################################
# construct strings from output
# MCMC convergence
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
ifelse(MCMC_effective_n == FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters."))
MCMC_checks_string
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.", "DD")
MCMC_convergence
MCMC_effective_n
n_eff_strings <-
capture.output(print(BEST)) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%
dplyr::filter(rowname > 3) %>%
dplyr::filter(rowname <= 8) %>%
select(-rowname)
colnames(n_eff_strings) <- "strings"
MCMC_checks <-
reshape2::colsplit(string = n_eff_strings$strings,
pattern = "\\s+",
names = c("parameter", "mean", "sd", "median", "HDIlo", "HDIup", "Rhat", "n.eff")) %>%
select(parameter, Rhat, n.eff) %>%
mutate(Rhat_sufficient = ifelse(Rhat > 1.05, 0, 1),  # insufficient convergence if less than value
n_eff_sufficient = ifelse(n.eff <= 10000, 0, 1)) %>%  # insufficient effective sample size if less than value
summarize(Rhat_sufficient = as.logical(min(Rhat_sufficient)),
n_eff_sufficient = as.logical(min(n_eff_sufficient)))
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.", "DD")
ifelse(MCMC_effective_n == FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters."))
MCMC_convergence        <- MCMC_checks$Rhat_sufficient
MCMC_effective_n        <- MCMC_checks$n_eff_sufficient
MCMC_effective_n
MCMC_convergence
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
ifelse(MCMC_effective_n == FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters."))
MCMC_checks_string
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN. ",
ifelse(MCMC_effective_n == FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN. ",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters. "))
BEST_text               <- sprintf("%s The posterior probabilities of a BEST test with %s as DV and condition as IV indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
MCMC_checks_string,
DV_name,
es_greater_zero,
es_in_rope,
es_size,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
DV_name,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b,
conclusions)
es_mode                 <- BEST_output_df %>% filter(rowname == "effSz") %>% .$mode
es_hdi_low              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIlo
es_hdi_high             <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIup
es_greater_zero         <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_greater_than_zero
es_in_rope              <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_in_rope
m_condition_a           <- BEST_output_df %>% filter(rowname == "mu1") %>% .$mean
m_condition_a           <- round(m_condition_a, 2)
m_condition_b           <- BEST_output_df %>% filter(rowname == "mu2") %>% .$mean
m_condition_b           <- round(m_condition_b, 2)
BEST_text               <- sprintf("%s The posterior probabilities of a BEST test with %s as DV and condition as IV indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
MCMC_checks_string,
DV_name,
es_greater_zero,
es_in_rope,
es_mode,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
DV_name,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b,
conclusions)
es_size                 <- ifelse(abs(es_mode) < 0.2, "negligable",
ifelse(abs(es_mode) < 0.5, "small",
ifelse(abs(es_mode) < 0.8, "medium", "large")))
# assess if >=95% of credible es are inside the ROPE
equality_boolean        <- ifelse(es_in_rope >= 95, 1, 0)
# assess if the 95% HDI includes the zero point
es_hid_includes_zero    <- ifelse(m_condition_a * m_condition_b < 0,  # if the product of the number is negative then one is positive and one is negative, therefore the interval contains zero. Otherwise, it does not.
"overlapped zero",
"did not overlap zero")
# Assess 3 way decision path based on equality and differences booleans to make a final conclusion
conclusions             <- ifelse(equality_boolean == 1,  # NB even if differences==1 here, effect is still so small as to consider groups equal.
"were credibly equal. ",
ifelse(es_hid_includes_zero == "did not overlap zero",
"were credibly different. ",
"were neither credibly different nor credibly equal. No firm conclusions could therefore be drawn. "))
BEST_text               <- sprintf("%s The posterior probabilities of a BEST test with %s as DV and condition as IV indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
MCMC_checks_string,
DV_name,
es_greater_zero,
es_in_rope,
es_size,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
DV_name,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b,
conclusions)
BEST_text
MCMC_checks_string      <- ifelse(MCMC_convergence == FALSE,
"The MCMC chains did not converge well. NB 'burnInSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
ifelse(MCMC_effective_n == FALSE,
"The effective sample size was insufficient for one or more parameter. NB 'numSavedSteps' OR 'thinSteps' SHOULD BE INCREASED AND THE TEST RE-RUN.",
"The MCMC chains converged well and had an effective sample size (ESS) greater than 10,000 for all parameters."))
BEST_text               <- sprintf("%s The posterior probabilities of a BEST test with %s as DV and condition as IV indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
MCMC_checks_string,
DV_name,
es_greater_zero,
es_in_rope,
es_size,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
DV_name,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b,
conclusions)
BEST_text
?colsplit
?capture.output
