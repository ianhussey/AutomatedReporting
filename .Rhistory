ROPEeff = c(-0.2,0.2))) %>%  # ROPE defined here
tibble::rownames_to_column() %>%  # convert rowname to column
mutate(mode = round(mode, 2),  # round values and rename awkwardly named ones
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2),
mean = round(mean, 2))
es_mode                   <- BEST_output_df %>% filter(rowname == "effSz") %>% .$mode  # convert df to individual variables
es_hdi_low                <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIlo
es_hdi_high               <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIup
es_percent_greater_zero   <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_greater_than_zero
es_percent_in_rope        <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_in_rope
m_condition_a             <- BEST_output_df %>% filter(rowname == "mu1") %>% .$mean
m_condition_b             <- BEST_output_df %>% filter(rowname == "mu2") %>% .$mean
DV_name           <- "IAT D1 scores"
condition_a_name  <- "flowers condition"
condition_b_name  <- "insects condition"
es_size <- ifelse(abs(es_mode) < 0.2, "negligable",
ifelse(abs(es_mode) < 0.5, "small",
ifelse(abs(es_mode) < 0.8, "medium", "large")))
es_hid_includes_zero <-
ifelse(m_condition_a < m_condition_b & m_condition_b < 0, "did not overlap zero",  # if (a,b) < 0
ifelse(m_condition_a > m_condition_b & m_condition_a > 0, "did not overlap zero", # if 0 < (a,b)
"overlapped zero"))  # if a < 0 < b
conclusion <-
ifelse(m_condition_a < m_condition_b & m_condition_b < 0, "credible differences",  # if (a,b) < 0
ifelse(m_condition_a > m_condition_b & m_condition_a > 0, "credible differences", # if 0 < (a,b)
"no credible differences"))  # if a < 0 < b
BEST_text <- sprintf("A Bayesian BEST test was used to compare differences in %s between the %s and the %s. The model employed 5 parameters to describe the data: the means of both conditions (μ1, μ2), the standard deviations of both conditions (σ1, σ2), and a shared normality parameter (ν). We employed the default BEST prior, which is a noncommittal prior intended to have minimal impact on the posterior distribution. Specifically, for sample yi in (y1, y2), μi = normal(M = mean(yi), SD = sd(yi)*5)), σi = gamma(Mo = sd(yi), SD = sd(yi)*5), ν = gamma(M = 30, SD = 30). In order to allow us to assess group equality as well as group differences, a region of practical equivalence (ROPE) was defined on the effect size (i.e., negligible effect size: -0.2 < d < 0.2). The posterior probabilities indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s existed between the %s (M = %s) and %s (M = %s).",
DV_name,
condition_a_name,
condition_b_name,
es_percent_greater_zero,
es_percent_in_rope,
es_size,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
conclusion,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b)
cat(BEST_text)
# write data to disk
sink("output BEST.txt")
BEST_output_df
cat("\n")
cat("\n")
cat(BEST_text)
sink()
sink("output BEST.txt")
BEST_output_df
cat("\n")
cat("\n")
cat(BEST_text)
sink()
DV_name           <- "IAT D1 change scores"
condition_a_name  <- "flowers condition"
condition_b_name  <- "insects condition"
es_size <- ifelse(abs(es_mode) < 0.2, "negligable",
ifelse(abs(es_mode) < 0.5, "small",
ifelse(abs(es_mode) < 0.8, "medium", "large")))
es_hid_includes_zero <-
ifelse(m_condition_a < m_condition_b & m_condition_b < 0, "did not overlap zero",  # if (a,b) < 0
ifelse(m_condition_a > m_condition_b & m_condition_a > 0, "did not overlap zero", # if 0 < (a,b)
"overlapped zero"))  # if a < 0 < b
conclusion <-
ifelse(m_condition_a < m_condition_b & m_condition_b < 0, "credible differences",  # if (a,b) < 0
ifelse(m_condition_a > m_condition_b & m_condition_a > 0, "credible differences", # if 0 < (a,b)
"no credible differences"))  # if a < 0 < b
BEST_text <- sprintf("A Bayesian BEST test was used to compare differences in %s between the %s and the %s. The model employed 5 parameters to describe the data: the means of both conditions (μ1, μ2), the standard deviations of both conditions (σ1, σ2), and a shared normality parameter (ν). We employed the default BEST prior, which is a noncommittal prior intended to have minimal impact on the posterior distribution. Specifically, for sample yi in (y1, y2), μi = normal(M = mean(yi), SD = sd(yi)*5)), σi = gamma(Mo = sd(yi), SD = sd(yi)*5), ν = gamma(M = 30, SD = 30). In order to allow us to assess group equality as well as group differences, a region of practical equivalence (ROPE) was defined (negligible effect size: -0.2 < d < 0.2). The posterior probabilities indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s in %s existed between the %s (M = %s) compared to the %s (M = %s).",
DV_name,
condition_a_name,
condition_b_name,
es_percent_greater_zero,
es_percent_in_rope,
es_size,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
conclusion,
DV_name,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b)
# write data to disk
sink("output BEST.txt")
BEST_output_df
cat("\n")
cat("\n")
cat(BEST_text)
sink()
BEST_text <- sprintf("A Bayesian BEST test (Kruschke, 2013) was used to compare differences in %s between %s and %s. The model employed 5 parameters to describe the data: the means of both conditions (μ1, μ2), the standard deviations of both conditions (σ1, σ2), and a shared normality parameter (ν). We employed the default BEST prior, which is a noncommittal prior intended to have minimal impact on the posterior distribution. Specifically, for sample yi in (y1, y2), μi = normal(M = mean(yi), SD = sd(yi)*5)), σi = gamma(Mo = sd(yi), SD = sd(yi)*5), ν = gamma(M = 30, SD = 30). In order to allow us to assess group equality as well as group differences, a region of practical equivalence (ROPE) was defined (negligible effect size: -0.2 < d < 0.2). The posterior probabilities indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
DV_name,
condition_a_name,
condition_b_name,
es_percent_greater_zero,
es_percent_in_rope,
es_size,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
DV_name,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b,
conclusions)
differences <- ifelse(m_condition_a < m_condition_b & m_condition_b < 0,
1,  # if (a,b) < 0
ifelse(m_condition_a > m_condition_b & m_condition_a > 0,
1, # if 0 < (a,b)
0))  # if a < 0 < b
es_hid_includes_zero <- ifelse(differences == 1, "did not overlap zero", "overlapped zero")
equality <- ifelse(es_percent_in_rope >= 95, 1, 0)
conclusions <- ifelse(equality == 1,  # NB even if differences==1 here, effect is still so small as to consider groups equal.
"were credibly equal. ",
ifelse(differences == 1,
"were credbily different. ",
"were neither credibly different nor credibly equal. No firm conclusions could therefore be drawn"))
BEST_text <- sprintf("A Bayesian BEST test (Kruschke, 2013) was used to compare differences in %s between %s and %s. The model employed 5 parameters to describe the data: the means of both conditions (μ1, μ2), the standard deviations of both conditions (σ1, σ2), and a shared normality parameter (ν). We employed the default BEST prior, which is a noncommittal prior intended to have minimal impact on the posterior distribution. Specifically, for sample yi in (y1, y2), μi = normal(M = mean(yi), SD = sd(yi)*5)), σi = gamma(Mo = sd(yi), SD = sd(yi)*5), ν = gamma(M = 30, SD = 30). In order to allow us to assess group equality as well as group differences, a region of practical equivalence (ROPE) was defined (negligible effect size: -0.2 < d < 0.2). The posterior probabilities indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
DV_name,
condition_a_name,
condition_b_name,
es_percent_greater_zero,
es_percent_in_rope,
es_size,
es_hid_includes_zero,
es_mode,
es_hdi_low,
es_hdi_high,
DV_name,
condition_a_name,
m_condition_a,
condition_b_name,
m_condition_b,
conclusions)
BEST_text
equality_boolean <- ifelse(es_percent_in_rope >= 95, 1, 0)
BEST_output_df
BEST_output_df <-
as.data.frame(BEST) %>%  # convert to data frame for easier subsetting
summary(ROPEeff = c(-0.2,0.2)) %>%  # ROPE defined here
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename awkwardly named ones
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2),
mean = round(mean, 2))
BEST_output_df <-
as.data.frame(BEST)
BEST_output_df <-
as.data.frame(BEST) %>%  # convert to data frame for easier subsetting
summary(ROPEeff = c(-0.2,0.2))
BEST_output_df <-
as.data.frame(BEST) %>%  # convert to data frame for easier subsetting
summary(ROPEeff = c(-0.2,0.2)) %>%  # ROPE defined here
tibble::rownames_to_column()
BEST_output_df <-
summary(BEST, ROPEeff = c(-0.2,0.2)) %>%  # ROPE defined here
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename awkwardly named ones
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2),
mean = round(mean, 2))
rm(list=ls())
###################################################################
## Dependencies
library(BEST)
library(dplyr)
###################################################################
## Data acquisition
setwd("~/git/Automated Reporting/")
data_df <- read.csv("dataset.csv")
###################################################################
load(file="BEST.RData")
BEST_output_df <-
summary(BEST, ROPEeff = c(-0.2,0.2)) %>%  # ROPE defined here
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mode = round(mode, 2),  # round values and rename awkwardly named ones
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2),
mean = round(mean, 2))
# pull out individual variables for easier printing
es_mode               <- BEST_output_df %>% filter(rowname == "effSz") %>% .$mode
es_hdi_low            <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIlo
es_hdi_high           <- BEST_output_df %>% filter(rowname == "effSz") %>% .$HDIup
es_greater_zero       <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_greater_than_zero
es_in_rope            <- BEST_output_df %>% filter(rowname == "effSz") %>% .$percent_in_rope
m_condition_a         <- BEST_output_df %>% filter(rowname == "mu1") %>% .$mean
m_condition_b         <- BEST_output_df %>% filter(rowname == "mu2") %>% .$mean
########################################################################
# construct strings
DV_name               <- "IAT D1 change scores"
condition_a_name      <- "the flowers condition"
condition_b_name      <- "the insects condition"
es_size               <- ifelse(abs(es_mode) < 0.2, "negligable",
ifelse(abs(es_mode) < 0.5, "small",
ifelse(abs(es_mode) < 0.8, "medium", "large")))
differences_boolean   <- ifelse(m_condition_a < m_condition_b & m_condition_b < 0,
1,  # if (a,b) < 0
ifelse(m_condition_a > m_condition_b & m_condition_a > 0,
1, # if 0 < (a,b)
0))  # if a < 0 < b
es_hid_includes_zero  <- ifelse(differences_boolean == 1,
"did not overlap zero",
"overlapped zero")
equality_boolean      <- ifelse(es_in_rope >= 95,
1,
0)
conclusions           <- ifelse(equality == 1,  # NB even if differences==1 here, effect is still so small as to consider groups equal.
"were credibly equal. ",
ifelse(differences == 1,
"were credbily different. ",
"were neither credibly different nor credibly equal. No firm conclusions could therefore be drawn"))
DV_name               <- "IAT D1 change scores"
condition_a_name      <- "the flowers condition"
condition_b_name      <- "the insects condition"
# interpret effect size based on Cohen's (1988) guidelines
es_size               <- ifelse(abs(es_mode) < 0.2, "negligable",
ifelse(abs(es_mode) < 0.5, "small",
ifelse(abs(es_mode) < 0.8, "medium", "large")))
# assess if >=95% of credible es are inside the ROPE
equality_boolean      <- ifelse(es_in_rope >= 95, 1, 0)
# assess if the 95% HDI includes the zero point
differences_boolean   <- ifelse(m_condition_a < m_condition_b & m_condition_b < 0,
1,  # if (a,b) < 0
ifelse(m_condition_a > m_condition_b & m_condition_a > 0,
1, # if 0 < (a,b)
0))  # if a < 0 < b
# set a string depending on the above boolean
es_hid_includes_zero  <- ifelse(differences_boolean == 1,
"did not overlap zero",
"overlapped zero")
# Assess 3 way decision path based on equality and differences booleans to make a final conclusion
conclusions           <- ifelse(equality_boolean == 1,  # NB even if differences==1 here, effect is still so small as to consider groups equal.
"were credibly equal. ",
ifelse(differences_boolean == 1,
"were credbily different. ",
"were neither credibly different nor credibly equal. No firm conclusions could therefore be drawn"))
########################################################################
# combine all into a natural langauge string
BEST_text             <- sprintf("A Bayesian BEST test (Kruschke, 2013) was used to compare differences in %s between %s and %s. The model employed 5 parameters to describe the data: the means of both conditions (μ1, μ2), the standard deviations of both conditions (σ1, σ2), and a shared normality parameter (ν). We employed the default BEST prior, which is a noncommittal prior intended to have minimal impact on the posterior distribution. Specifically, for sample yi in (y1, y2), μi = normal(M = mean(yi), SD = sd(yi)*5)), σi = gamma(Mo = sd(yi), SD = sd(yi)*5), ν = gamma(M = 30, SD = 30). In order to allow us to assess group equality as well as group differences, a region of practical equivalence (ROPE) was defined (negligible effect size: -0.2 < d < 0.2). The posterior probabilities indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
DV_name, condition_a_name, condition_b_name, es_greater_zero,
es_in_rope, es_size, es_hid_includes_zero, es_mode, es_hdi_low,
es_hdi_high, DV_name, condition_a_name, m_condition_a, condition_b_name,
BEST_text             <- sprintf("A Bayesian BEST test (Kruschke, 2013) was used to compare differences in %s between %s and %s. The model employed 5 parameters to describe the data: the means of both conditions (μ1, μ2), the standard deviations of both conditions (σ1, σ2), and a shared normality parameter (ν). We employed the default BEST prior, which is a noncommittal prior intended to have minimal impact on the posterior distribution. Specifically, for sample yi in (y1, y2), μi = normal(M = mean(yi), SD = sd(yi)*5)), σi = gamma(Mo = sd(yi), SD = sd(yi)*5), ν = gamma(M = 30, SD = 30). In order to allow us to assess group equality as well as group differences, a region of practical equivalence (ROPE) was defined (negligible effect size: -0.2 < d < 0.2). The posterior probabilities indicated that %s%% of credible effect sizes were greater than 0, and %s%% were within the ROPE. The most credible effect size was of %s size with a highest density interval that %s, Mode d = %s, 95%% HDI [%s, %s]. We therefore concluded that %s between %s (M = %s) and %s (M = %s) %s",
DV_name, condition_a_name, condition_b_name, es_greater_zero, es_in_rope, es_size,
es_hid_includes_zero, es_mode, es_hdi_low, es_hdi_high, DV_name, condition_a_name,
m_condition_a, condition_b_name, m_condition_b, conclusions)
BEST_text
sink("output BEST.txt")
cat(BEST_text)
sink()
BEST_output_df
BEST_output_df
BEST_output_df <-
summary(BEST, ROPEeff = ROPE) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mean = round(mean, 2),
median = round(median, 2),
mode = round(mode, 2),  # round values and rename awkwardly named ones
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2))
ROPE <- c(-0.2, 0.2)
BEST_output_df <-
summary(BEST, ROPEeff = ROPE) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mean = round(mean, 2),
median = round(median, 2),
mode = round(mode, 2),  # round values and rename awkwardly named ones
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2))
BEST_output_df
# tidy up output
BEST_output_df <-
summary(BEST, ROPEeff = ROPE) %>%
as.data.frame() %>%  # convert to data frame for easier subsetting
tibble::rownames_to_column() %>%  # convert rowname to column for subsetting
mutate(mean = round(mean, 2),
median = round(median, 2),
mode = round(mode, 2),  # round values and rename awkwardly named ones
HDIlo = round(HDIlo, 2),
HDIup = round(HDIup, 2),
percent_greater_than_zero = round(`%>compVal`, 2),
percent_in_rope = round(`%InROPE`, 2)) %>%
select(-`%InROPE`, -`%>compVal`)
BEST_output_df
########################################################################
# Automated reporting of an independent t test and cohen's d
# for use in knittr scripts
# Ian Hussey (ian.hussey@ugent.be)
# output checked against results returned by JASP
# usage:
# 1. customise the working directory line, containing setwd() below
# 2. run script
# to do:
# report if one sided t test
#
########################################################################
# Clean workspace
rm(list=ls())
########################################################################
# dependencies
library(dplyr)
library(effsize)
library(weights)  # for rd(), a round() alternative
########################################################################
# data acquisition
setwd("~/git/Automated Reporting/")
data_df <- read.csv("dataset.csv")
########################################################################
## tests
# t test
t_test <- t.test(formula = change_score ~ condition,  # IV ~ DV adjusted here
data = data_df,
alternative = "two.sided",
paired = FALSE)
# effect size
cohens_d <- cohen.d(change_score ~ condition,
data = data_df,
paired = FALSE)
# descriptive stats by cell
desc_stats <-
ez::ezStats(data = data_df,
dv = .(change_score),
wid = .(participant),
between = .(condition),
type = 3) %>%
mutate(Mean = round(Mean, 2),  # round for later reporting
SD = round(SD, 2)) %>%
select(-FLSD)
########################################################################
## extract individual stats
# ideally this would be left to schoRsch but D returns NA
#my_t_test_output <- schoRsch::t_out(my_t_test,
#                                    n.equal = TRUE,
#                                    welch.df.exact = TRUE,
#                                    welch.n = NA,
#                                    d.corr = FALSE,
#                                    print = TRUE)
#returns: d = NA for some reason.
# t test
t_test_est        <- round(t_test$statistic[[1]], 2)
t_test_df         <- round(t_test$parameter[[1]], 2)
t_test_p          <- round(t_test$p.value[[1]], 5)
# effect size
d_est             <- round(cohens_d$estimate[[1]], 2)
d_ci_lower        <- round(cohens_d$conf.int[["inf"]], 2)
d_ci_upper        <- round(cohens_d$conf.int[["sup"]], 2)
d_interpretation  <- cohens_d$magnitude[[1]]
# round p values using APA rules
t_test_p <- ifelse(t_test_p < 0.001, "< .001",
ifelse(t_test_p < 0.01,
paste("= ", rd(t_test_p, 3), sep = ""),  # rd() rounds, converts to string, and removes the leading 0.
paste("= ", rd(t_test_p, 2), sep = "")))
## descriptives
a_m   <- desc_stats %>% filter(condition == "a") %>% .$Mean  # convert df to individual variables
b_m   <- desc_stats %>% filter(condition == "b") %>% .$Mean
a_sd  <- desc_stats %>% filter(condition == "a") %>% .$SD
b_sd  <- desc_stats %>% filter(condition == "b") %>% .$SD
a_n   <- desc_stats %>% filter(condition == "a") %>% .$N
b_n   <- desc_stats %>% filter(condition == "b") %>% .$N
########################################################################
# convert output to natural langauge
# set the DV and condition names
DV_name               <- "IAT D1 change scores"
condition_a_name      <- "the low condition"
condition_b_name      <- "the high condition"
nhst <- ifelse(t_test_p < 0.05,
paste("An independent t test demonstrated significant differences of ", d_interpretation, " effect size in ", DV_name, " between ", condition_a_name, " and ", condition_b_name, sep = ""),
paste("An independent t test demonstrated non-significant differences of ", d_interpretation, " effect size between ", sep = ""))
# t test and d
t_test_output <- paste(", t(", t_test_df, ") = ", t_test_est, ", p ", t_test_p, ", d = ", d_est, ", 95% CI [", d_ci_lower, ", ", d_ci_upper, "]. ", sep = "")
# descriptive stats
desc_a <- paste("condition A (n = ", a_n, ", M = ", a_m, ", SD = ", a_sd, ")", sep = "")
desc_b <- paste("condition B (n = ", b_n, ", M = ", b_m, ", SD = ", b_sd, ")", sep = "")
########################################################################
## combine and write to disk
## final summary
t_test_text <- paste(nhst,
desc_a,
" and ",
desc_b,
t_test_output,
sep = "")
## write to disk
sink("output t test independent.txt")
cat(t_test_text)  # cat() supresses the line number from being printed
sink()
data_df <- read.csv("dataset.csv")
data_df <- read.csv("dataset.csv")
########################################################################
## tests
# t test
t_test <- t.test(formula = change_score ~ condition,  # IV ~ DV adjusted here
data = data_df,
alternative = "two.sided",
paired = FALSE)
# effect size
cohens_d <- cohen.d(change_score ~ condition,
data = data_df,
paired = FALSE)
# descriptive stats by cell
desc_stats <-
ez::ezStats(data = data_df,
dv = .(change_score),
wid = .(participant),
between = .(condition),
type = 3) %>%
mutate(Mean = round(Mean, 2),  # round for later reporting
SD = round(SD, 2)) %>%
select(-FLSD)
########################################################################
## extract individual stats
# ideally this would be left to schoRsch but D returns NA
#my_t_test_output <- schoRsch::t_out(my_t_test,
#                                    n.equal = TRUE,
#                                    welch.df.exact = TRUE,
#                                    welch.n = NA,
#                                    d.corr = FALSE,
#                                    print = TRUE)
#returns: d = NA for some reason.
# t test
t_test_est        <- round(t_test$statistic[[1]], 2)
t_test_df         <- round(t_test$parameter[[1]], 2)
t_test_p          <- round(t_test$p.value[[1]], 5)
# effect size
d_est             <- round(cohens_d$estimate[[1]], 2)
d_ci_lower        <- round(cohens_d$conf.int[["inf"]], 2)
d_ci_upper        <- round(cohens_d$conf.int[["sup"]], 2)
d_interpretation  <- cohens_d$magnitude[[1]]
# round p values using APA rules
t_test_p <- ifelse(t_test_p < 0.001, "< .001",
ifelse(t_test_p < 0.01,
paste("= ", rd(t_test_p, 3), sep = ""),  # rd() rounds, converts to string, and removes the leading 0.
paste("= ", rd(t_test_p, 2), sep = "")))
## descriptives
a_m   <- desc_stats %>% filter(condition == "a") %>% .$Mean  # convert df to individual variables
b_m   <- desc_stats %>% filter(condition == "b") %>% .$Mean
a_sd  <- desc_stats %>% filter(condition == "a") %>% .$SD
b_sd  <- desc_stats %>% filter(condition == "b") %>% .$SD
a_n   <- desc_stats %>% filter(condition == "a") %>% .$N
b_n   <- desc_stats %>% filter(condition == "b") %>% .$N
########################################################################
# convert output to natural langauge
# set the DV and condition names
DV_name               <- "IAT D1 change scores"
condition_a_name      <- "the low condition"
condition_b_name      <- "the high condition"
nhst <- ifelse(t_test_p < 0.05,
paste("An independent t test demonstrated significant differences of ", d_interpretation, " effect size in ", DV_name, " between ", condition_a_name, " and ", condition_b_name, sep = ""),
paste("An independent t test demonstrated non-significant differences of ", d_interpretation, " effect size between ", sep = ""))
# t test and d
t_test_output <- paste(", t(", t_test_df, ") = ", t_test_est, ", p ", t_test_p, ", d = ", d_est, ", 95% CI [", d_ci_lower, ", ", d_ci_upper, "]. ", sep = "")
desc_a <- paste("condition A (n = ", a_n, ", M = ", a_m, ", SD = ", a_sd, ")", sep = "")
desc_b <- paste("condition B (n = ", b_n, ", M = ", b_m, ", SD = ", b_sd, ")", sep = "")
########################################################################
## combine and write to disk
## final summary
t_test_text <- paste(nhst,
desc_a,
" and ",
desc_b,
t_test_output,
sep = "")
sink("output t test independent.txt")
cat(t_test_text)  # cat() supresses the line number from being printed
sink()
DV_name               <- "IAT D1 change scores"
condition_a_name      <- "the low condition"
condition_b_name      <- "the high condition"
nhst <- ifelse(t_test_p < 0.05,
paste("An independent t test demonstrated significant differences of ", d_interpretation, " effect size in ", DV_name, " between ", sep = ""),
paste("An independent t test demonstrated non-significant differences of ", d_interpretation, " effect size between ", sep = ""))
# t test and d
t_test_output <- paste(", t(", t_test_df, ") = ", t_test_est, ", p ", t_test_p, ", d = ", d_est, ", 95% CI [", d_ci_lower, ", ", d_ci_upper, "]. ", sep = "")
# descriptive stats
desc_a <- paste(condition_a_name, " (n = ", a_n, ", M = ", a_m, ", SD = ", a_sd, ")", sep = "")
desc_b <- paste(condition_b_name, " (n = ", b_n, ", M = ", b_m, ", SD = ", b_sd, ")", sep = "")
########################################################################
## combine and write to disk
## final summary
t_test_text <- paste(nhst,
desc_a,
" and ",
desc_b,
t_test_output,
sep = "")
## write to disk
sink("output t test independent.txt")
cat(t_test_text)  # cat() supresses the line number from being printed
sink()
